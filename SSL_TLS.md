# TLS/SSL
## History of TLS/SSL
1. SSL 1.0 by Netscape
2. SSL 2.0 released in Feb 1995
3. SSL 3.0 released in 1996 (A complete redesign of the protocol produced by Paul Kocher working with Netscape engineers Phil Karlton and Alan Freier, with a reference implementation by Christopher Allen and Tim Dierks of Consensus Development)
4. TLS 1.0 defined in Jan 1999 as an upgrade of SSL 3.0
5. TLS 1.1 defined in April 2006 as an update of TLS 1.0
6. TLS 1.2 defined in Aug 2008 base on TLS 1.1
7. All TLS versions were further refined in in March 2011, removing their backward compatibility with SSL such that TLS sessions never negotiate the use of Secure Sockets Layer (SSL) version 2.0.
8. POODLE attack in 2014, facilitate SSL 3.0 being prohibited in 2015
9. TLS 1.3 defined in Aug 2018 base on TLS 1.2

>**The PCI Council suggests that organizations migrate from TLS 1.0 to TLS 1.1 or higher before June 30, 2018.[20][21] In October 2018, Apple, Google, Microsoft, and Mozilla jointly announced they would deprecate TLS 1.0 and 1.1 in March 2020.**

## What is TLS/SSL?
>Transport Layer Security (TLS)
>Secure Sockets Layer (SSL)
>1. TLS aims primarily to provide privacy and data integrity between two or more communicating computer applications.
>2. TLS will use symmetric cryptography to encrypt data transimitted.
>3. Keys for symmetric cryptography are generated uniquely for each connection whdn doing TLS handshake
>4. Identity of the communication parties can be authenticated using public-key cryptography. The authentication is optional, but require for at least one of the parites (typically the server).
>5. Connection is reliable cause each message transmitted includes a message integrity check using a message authentication code

So there are 3 important parts in TLS
* Key exchange algorithm e.g. RSA, DH
* Bulk encryption algorithm e.g. 3DES_EDE_CBC
* Message authentication algorithm e.g. SHA

## Key Exchange Algorithm
### What is TLS Handshake?
```sequence
Client-->Server: SYN
Server-->Client: SYN ACK
Client-->Server: ACK
Note left of Server: Connection between Client and Server Established
Note left of Client: ClientHello
Client->Server: 1.highest TLS protocol ver, random number, \n suggested cipher suites and compression methods
Note right of Server: ServerHello
Server->Client: 2.TLS protocol ver, random number,\n CipherSuite and compression method
Server->Client: 3.Certificate 
Server->Client: 4.ServerKeyExchange if DH ciphersuites
Server->Client: 5.ServerHelloDone
Note left of Client: ClientKeyExchange
Client->Server: 6.encrypted PreMasterSecret, client's public key
Note over Client: 7.a Caculate SessionKey use PreMasterSecret, \nclient and server's random numbers \n 
Note over Server: 7.b Caculate SessionKey use PreMasterSecret, \nclient and server's random numbers
Note left of Client: ChangeCipherSpec
Client->Server: 8.To notify from now on message been authenticated)
Client->Server:9.Finish message(hash, MAC)
Note over Server: 10.Decrypt Finish message,\nverify hash and MAC
Note right of Server: ChangeCipherSpec
Server->Client: 11.To notify from now on message been authenticated
Server->Client:12.Finish message
Note over Client: 13. Decrypt Finish message and verify
Note left of Server: Handshake complete, begin Application phase
Client->Server: Application data encrypted using [SessionKey]
Note over Server: Decrypt using [SessionKey] \n and get application data
```

### How to keep the SessionKey generated by Client and Server seperately the same?
For RSA:
In step 1, Client will send its **random number** to Server.
In step 2, Server will send its **random number** to Client.
In step 6, **PreMasterSecret** is generated randomly by Clientï¼Œ encrypted using Server's public key and send from Client to Server. So Server can use its private key decrypt and get **PreMasterSecret**.
Now both Client and Server know the same info about **PreMasterSecret**, Client's **random number** and Server's **random number**. They can use the three to generate **SessionKey**.
e.g. **PreMasterSecret** + Client's **random number** + Server's **random number**

For DH:


### What is difference between DH and RSA?
If we use RSA, we will send Client's **random number**, Server's **random number** and the Enrypted **PreMasterSecret**. So if we get Server's privatekey, and capture **PreMasterSecret**, we can easily get the sessionkey, and decrypt each data encrypted.
If we use EDH, we will send Client's **random number**, Server's **random number** and Server's **DH parameter**, Client's **DH parameter** which is calculated by g,p,and randowm number. So if we want to generate the same Session Key, we need to capture the DH parameter and 
Q3: In Step 9, what is the hash and MAC comes from?



